/* This file is part of VoltDB.
 * Copyright (C) 2008-2010 VoltDB L.L.C.
 *
 * VoltDB is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * VoltDB is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with VoltDB.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.voltdb.dtxn;

import org.voltdb.VoltDB;
import org.voltdb.SiteStatsSource;
import org.voltdb.StoredProcedureInvocation;
import org.voltdb.SysProcSelector;
import org.voltdb.VoltType;
import org.voltdb.VoltTable.ColumnInfo;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Class that provides storage for statistical information generated by an Initiator
 */
public class InitiatorStats extends SiteStatsSource {


    /**
     * Map from the combined key of ConnectionId and ProcedureName to statistical information related to the specific procedure.
     */
    private final ConcurrentHashMap<String, AtomicLong> m_connectionStats =
        new ConcurrentHashMap<String, AtomicLong>( 16, (float).5, 3);

    /**
     * Counter indicating how many initiators have been created on this node. Assumes the same number of initiators
     * are going to be created on each node in the cluster.
     */
    public static final AtomicLong initiatorIndex = new AtomicLong(0);

    /**
     *
     * @param name
     * @param siteId
     */
    public InitiatorStats(String name, int siteId) {
        super(name, siteId);
        VoltDB.instance().getStatsAgent().registerStatsSource(SysProcSelector.INITIATOR, (int)initiatorIndex.getAndIncrement(), this);
    }

    /**
     * Called by the Initiator every time a transaction is created to perform a specific invocation
     * @param connectionId Id of the connection that the invocation orginated from
     * @param invocation Procedure being invoked
     */
    public void logTransactionCreated(int connectionId, StoredProcedureInvocation invocation) {
        final StringBuffer key = new StringBuffer(2048);
        key.append(invocation.getProcName()).append('$').append(connectionId);
        final String keyString = key.toString();
        AtomicLong procedureInvocations = new AtomicLong(1);
        procedureInvocations = m_connectionStats.putIfAbsent(keyString, procedureInvocations);
        if (procedureInvocations != null) {
            procedureInvocations.incrementAndGet();
        }
    }

    @Override
    protected void populateColumnSchema(ArrayList<ColumnInfo> columns) {
        super.populateColumnSchema(columns);
        columns.add(new ColumnInfo("CONNECTION_ID", VoltType.INTEGER));
        columns.add(new ColumnInfo("PROCEDURE_NAME", VoltType.STRING));
        columns.add(new ColumnInfo("PROCEDURE_INVOCATIONS", VoltType.BIGINT));
    }

    @Override
    protected void updateStatsRow(final Object rowKey, Object rowValues[]) {
        AtomicLong procedureInvocations = m_connectionStats.get(rowKey);
        final String statsKey = (String)rowKey;
        final String statsKeySplit[] = statsKey.split("\\$");
        final String procName = statsKeySplit[0];
        final String connectionId = statsKeySplit[1];
        rowValues[columnNameToIndex.get("CONNECTION_ID")] = new Integer(connectionId);
        rowValues[columnNameToIndex.get("PROCEDURE_NAME")] = procName;
        rowValues[columnNameToIndex.get("PROCEDURE_INVOCATIONS")] = procedureInvocations;
        super.updateStatsRow(rowKey, rowValues);
    }

    /**
     * A dummy iterator that wraps an Iterator<String> and provides the Iterator<Object> necessary
     * for getStatsRowKeyIterator()
     *
     */
    private class DummyIterator implements Iterator<Object> {
        private final Iterator<String> i;

        private DummyIterator(Iterator<String> i) {
            this.i = i;
        }

        @Override
        public boolean hasNext() {
            return i.hasNext();
        }

        @Override
        public Object next() {
            return i.next();
        }

        @Override
        public void remove() {
            i.remove();
        }


    }

    @Override
    protected Iterator<Object> getStatsRowKeyIterator() {
        return new DummyIterator(m_connectionStats.keySet().iterator());
    }

}
