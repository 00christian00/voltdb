#!/usr/bin/env python
# This file is part of VoltDB.

# Copyright (C) 2008-2011 VoltDB Inc.
#
# This file contains original code and/or modifications of original code.
# Any modifications made by VoltDB Inc. are licensed under the following
# terms and conditions:
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

# The VoltDB master command script
#
# Environment Variables
#   JAVA_HOME          The java implementation to use.  Overrides JAVA_HOME.
#   JAVA_HEAP_MAX      The maximum amount of heap to use, in MB. Default is 1024.
#   VOLTDB_OPTS        Extra Java runtime options.
#   LOG4J_CONFIG_PATH  Path to alternate log4j configuration

import sys
import os
import optparse
import glob
import re
import shlex

mydir, myname = os.path.split(os.path.realpath(sys.argv[0]))

#### Utility functions

def _message(f, tag, *msgs):
    '''Low level message display.'''
    if tag:
        stag = '%8s: ' % tag
    else:
        stag = ''
    for msg in msgs:
        if msg is not None:
            # Handle exceptions
            if issubclass(msg.__class__, Exception):
                f.write('%s%s Exception: %s\n' % (stag, msg.__class__.__name__, str(msg)))
            else:
                # Handle multi-line strings
                try:
                    # Raises TypeError if not string
                    t = msg + ' '
                    # If it is a string slice and dice it by linefeeds.
                    for msg2 in msg.split('\n'):
                        f.write('%s%s\n' % (stag, msg2))
                except TypeError:
                    if hasattr(msg, '__iter__'):
                        for msg2 in msg:
                            f.write('%s   %s\n' % (stag, msg2))
                    else:
                        f.write('%s%s\n' % (stag, str(msg)))

def info(*msgs):
    _message(sys.stdout, 'INFO', *msgs)

def debug(*msgs):
    if GLOBAL.options.debug:
        _message(sys.stdout, 'DEBUG', *msgs)

def warning(*msgs):
    _message(sys.stdout, 'WARNING', *msgs)

def error(*msgs):
    _message(sys.stderr, 'ERROR', *msgs)

def abort(*msgs):
    error(*msgs)
    _message(sys.stderr, 'FATAL', 'Errors are fatal, aborting execution')
    sys.exit(1)

def run_cmd(cmd, *args):
    '''Run an external program without capturing or suppressing output and
    check the return code.'''
    fullcmd = cmd
    for arg in args:
        if len(arg.split()) > 1:
            fullcmd += ' "%s"' % arg
        else:
            fullcmd += ' %s' % arg
    if GLOBAL.options.dryrun:
        print fullcmd
    else:
        retcode = os.system(fullcmd)
        if retcode != 0:
            abort('return code %d: %s' % (retcode, fullcmd))

def pipe_cmd(*args):
    '''Run an external program, capture its output, and yield each output line
    for iteration.'''
    try:
        proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        for line in iter(proc.stdout.readline, ''):
            yield line.rstrip()
        proc.stdout.close()
    except Exception, e:
        warning('Exception running command: %s' % ' '.join(args), e)

def initialize_environment():
    '''Set the VOLTDB_HOME, VOLTDB_LIB and VOLTDB_VOLTDB environment variables
    based on the location of this script.'''

    global mydir
    dir = mydir

    # Crawl upward and look for the home, lib and voltdb directories.
    # They may be the same directory when installed by a Linux installer.
    # Set the VOLTDB_... environment variables accordingly.
    # Also locate the voltdb jar file.
    while (    dir != '/'
           and (   'VOLTDB_HOME'   not in os.environ
                or 'VOLTDB_LIB'    not in os.environ
                or 'VOLTDB_VOLTDB' not in os.environ)):

        # Try to set VOLTDB_HOME if not set.
        if not os.environ.get('VOLTDB_HOME', ''):
            for subdir in ('', os.path.join('share', 'voltdb')):
                for chk in ('Click Here to Start.html', 'examples', 'third_party'):
                    if not os.path.exists(os.path.join(dir, subdir, chk)):
                        break
                else:
                    os.environ['VOLTDB_HOME'] = os.path.realpath(os.path.join(dir, subdir))

        # Try to set VOLTDB_LIB if not set.
        if not os.environ.get('VOLTDB_LIB', ''):
            for subdir in ('lib', os.path.join('lib', 'voltdb')):
                if glob.glob(os.path.join(os.path.join(dir, subdir), 'zmq*.jar')):
                    os.environ['VOLTDB_LIB'] = os.path.realpath(os.path.join(dir, subdir))

        # Try to set VOLTDB_VOLTDB if not set. Look for the voltdb jar file.
        if not os.environ.get('VOLTDB_VOLTDB', ''):
            for subdir in ('voltdb', os.path.join('lib', 'voltdb')):
                for voltdb_jar in glob.glob(os.path.join(os.path.join(dir, subdir), 'voltdb*.jar')):
                    if GLOBAL.re_voltdb_jar.match(os.path.basename(voltdb_jar)):
                        GLOBAL.voltdb_jar = os.path.realpath(voltdb_jar)
                        os.environ['VOLTDB_VOLTDB'] = os.path.dirname(GLOBAL.voltdb_jar)

        dir = os.path.dirname(dir)
    if (   'VOLTDB_HOME'   not in os.environ
        or 'VOLTDB_LIB'    not in os.environ
        or 'VOLTDB_VOLTDB' not in os.environ):
        abort('Failed to determine VoltDB environment:',
                (var
                    for var in ('VOLTDB_HOME', 'VOLTDB_LIB', 'VOLTDB_VOLTDB')
                        if var not in os.environ))

    # LOG4J configuration
    if 'LOG4J_CONFIG_PATH' not in os.environ:
        for subdirs in (('$VOLTDB_HOME', 'src', 'frontend'), ('$VOLTDB_HOME', 'voltdb')):
            path = os.path.join(os.path.expandvars(os.path.join(*subdirs)), 'log4j.xml')
            if os.path.exists(path):
                os.environ['LOG4J_CONFIG_PATH'] = path
                break
        else:
            abort('Could not find log4j configuration file or LOG4J_CONFIG_PATH variable.')

    for var in ('VOLTDB_HOME', 'VOLTDB_LIB', 'VOLTDB_VOLTDB', 'LOG4J_CONFIG_PATH'):
        debug('%s=%s' % (var, os.environ[var]))

    # Classpath is the voltdb jar and all the jars in VOLTDB_LIB.
    GLOBAL.classpath = [GLOBAL.voltdb_jar]
    for path in glob.glob(os.path.join(os.environ['VOLTDB_LIB'], '*.jar')):
        GLOBAL.classpath.append(path)

def find_in_path(name):
    '''Find program in the system path.'''
    # NB: non-portable
    for dir in os.environ['PATH'].split(':'):
        if os.path.exists(os.path.join(dir, 'java')):
            return os.path.join(dir, 'java')
    return None

#### Metadata class

class MetaData(object):
    def __init__(self, **kwargs):
        if 'description' not in kwargs or 'usage' not in kwargs:
            abort('Metadata must have both "description" and "usage" members.')
        self._kwargs = kwargs
    def __getattr__(self, name):
        return self._kwargs.get(name, None)

#### Option class

class CLIOption(object):
    def __init__(self, *args, **kwargs):
        self.args   = args
        self.kwargs = kwargs

#### Verb runner class

class VerbRunner(object):

    def __init__(self, name, options, args, parser):
        self.name      = name
        self.options   = options
        self.args      = args
        self.parser    = parser
        self.classpath = GLOBAL.classpath

    def abort(self, *msgs):
        error('Fatal error in "%s" command.' % self.name, *msgs)
        print ''
        self.parser.print_help()
        print ''
        abort()

    def classpath_prepend(self, *paths):
        self.classpath = list(paths) + self.classpath

    def classpath_append(self, *paths):
        self.classpath = self.classpath + list(paths)

    def java(self, java_class, *args):
        java_args = [GLOBAL.java]
        java_args.extend(GLOBAL.java_opts)
        java_args.append('-Dlog4j.configuration=file://%s' % os.environ['LOG4J_CONFIG_PATH'])
        java_args.append('-classpath')
        java_args.append(':'.join(self.classpath))
        java_args.append(java_class)
        java_args.extend(args)
        return run_cmd(*java_args)

#### Verb: abstract base class

class Verb(object):
    def __init__(self, name, **kwargs):
        self.name     = name
        self.metadata = MetaData(**kwargs)
    def execute(self, env):
        abort('Verb "%s" object does not implement the required execute() method.' % self.name)

#### Verb: compile

class VerbCompile(Verb):
    def __init__(self):
        Verb.__init__(self, 'compile', 
                            description = 'Run the VoltDB compiler to build the catalog',
                            usage       = '%prog compile CLASSPATH PROJECT JAR')
    def execute(self, runner):
        if len(runner.args) != 3:
            runner.abort('3 arguments are required, %d were provided.' % len(runner.args))
        runner.classpath_prepend(runner.args[0])
        runner.classpath_append(runner.args[0])
        runner.java('org.voltdb.compiler.VoltCompiler', *runner.args[1:])

#### Verb: start

class VerbStart(Verb):
    def __init__(self):
        Verb.__init__(self, 'start',
                            description = 'Start the VoltDB server',
                            usage       = '%prog start [OPTIONS] JAR')
    def execute(self, env):
        pass

#### Globals

class GLOBAL:
    '''Provides all the global data.'''

    # CLI metadata.
    version = "0.9"
    version_string = '%%prog version %s' % version

    # Verbs support the possible actions.
    verbs = (
        VerbCompile(),
        VerbStart(),
    )

    # Options define the CLI behavior modifiers.
    metadata = MetaData(
        description = 'This serves as a comprehensive command line interface to VoltDB.',
        usage       = '%prog [OPTIONS] COMMAND [ARGUMENTS ...]',
        options     = (
            CLIOption('-d', '--debug', action = 'store_true', dest = 'debug',
                      help = 'display debug messages'),
            CLIOption('-n', '--dry-run', action = 'store_true', dest = 'dryrun',
                      help = 'perform dry run without executing actions'),
            CLIOption('-p', '--pause', action = 'store_true', dest = 'pause',
                      help = 'pause before significant actions'),
            CLIOption('-v', '--verbose', action = 'store_true', dest = 'verbose',
                      help = 'display verbose messages, including external command lines'),
        )
    )

    # Java configuration
    if 'JAVA_HOME' in os.environ:
        java = os.path.join(os.environ['JAVA_HOME'], 'java')
    else:
        java = find_in_path('java')
    if not java:
        abort('Could not find java in environment, set JAVA_HOME or put java in the path.')
    java_opts = []
    if 'JAVA_HEAP_MAX' in os.environ:
        java_opts.append(os.environ.get('JAVA_HEAP_MAX'))
    if 'VOLTDB_OPTS' in os.environ:
        java_opts.extend(shlex.split(os.environ['VOLTDB_OPTS']))
    if 'JAVA_OPTS' in os.environ:
        java_opts.extend(shlex.split(os.environ['JAVA_OPTS']))
    if not [opt for opt in java_opts if opt.startswith('-Xmx')]:
        java_opts.append('-Xmx1024m')

   # VoltDB jar file (filled in during startup)
    re_voltdb_jar = re.compile('^voltdb-2[.0-9]+[.]jar$')
    voltdb_jar = None

    # Classpath (filled in during startup)
    classpath = None

    # Filled in by option parser
    options = None

#### Option parser

class VoltCLIOptionParser(optparse.OptionParser):
    '''Parse and validate command line arguments.'''

    def __init__(self):
        usage = '%s\n' % GLOBAL.metadata.usage
        for verb in GLOBAL.verbs:
            usage += '\n       %s' % verb.metadata.usage
        optparse.OptionParser.__init__(self,
                description = GLOBAL.metadata.description,
                usage       = usage,
                version     = GLOBAL.version_string)
        for cli_option in GLOBAL.metadata.options:
            self.add_option(*cli_option.args, **cli_option.kwargs)

    def parse_args(self):

        # Separate the global options preceding the command from
        # command-specific options that follow it.
        iverb = 1
        while iverb < len(sys.argv):
            # Skip options and any associated option arguments.
            if sys.argv[iverb].startswith('-'):
                for opt in GLOBAL.metadata.options:
                    if sys.argv[iverb] in opt.args:
                        # Skip the argument of an option that takes one
                        if (not 'action' in opt.kwargs or opt.kwargs['action'] == 'store'):
                            iverb += 1
            else:
                # Found the command.
                break
            iverb += 1
        # Parse the global options. GLOBAL.args should be empty
        GLOBAL.options, args = optparse.OptionParser.parse_args(self, sys.argv[1:iverb])
        assert len(args) == 0

        if iverb == len(sys.argv):
            self._abort('Missing command.')
        verb_name = sys.argv[iverb].lower()
        for verb in GLOBAL.verbs:
            if verb.name == verb_name:
                break
        else:
            self._abort('Unknown command: %s' % verb_name)

        # Parse the command-specific options.
        verb_parser = optparse.OptionParser(description = verb.metadata.description,
                                            usage = verb.metadata.usage)
        if iverb + 1 < len(sys.argv):
            if verb.metadata.options:
                for opt in verb.metadata.options:
                    verb_parser.add_option(*opt.args, **opt.kwargs)
            options, args = verb_parser.parse_args(sys.argv[iverb+1:])
        else:
            options = None
            args = []

        return verb, options, args, verb_parser

    def _abort(self, *msgs):
            error(*msgs)
            sys.stderr.write('\n')
            self.print_help()
            sys.stderr.write('\n')
            abort()

    def format_epilog(self, formatter):
        max_verb_width = 0
        for verb in GLOBAL.verbs:
            max_verb_width = max(max_verb_width, len(verb.name))
        fmt = '%%-%ds  %%s' % max_verb_width
        return '''
COMMAND is one of the following:

%s
''' % '\n'.join([fmt % (verb.name, verb.metadata.description) for verb in GLOBAL.verbs])

#### Command line main

if __name__ == '__main__':
    parser = VoltCLIOptionParser()
    verb, options, args, verb_parser = parser.parse_args()
    initialize_environment()
    # Run the command.
    verb.execute(VerbRunner(verb.name, options, args, verb_parser))
