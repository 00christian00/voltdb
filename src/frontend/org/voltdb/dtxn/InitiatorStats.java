/* This file is part of VoltDB.
 * Copyright (C) 2008-2013 VoltDB Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with VoltDB.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.voltdb.dtxn;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Set;

import org.HdrHistogram.Histogram;
import org.voltcore.utils.EstTime;
import org.voltdb.ClientInterface;
import org.voltdb.SiteStatsSource;
import org.voltdb.StoredProcedureInvocation;
import org.voltdb.SysProcSelector;
import org.voltdb.VoltDB;
import org.voltdb.VoltTable.ColumnInfo;
import org.voltdb.VoltType;
import org.voltdb.client.ClientResponse;

/**
 * Class that provides storage for statistical information generated by an Initiator
 */
public class InitiatorStats extends SiteStatsSource {


    /**
     * Map from the combined key of ConnectionId and ProcedureName to statistical information related to the specific procedure.
     */
    private final HashMap<String, InvocationInfo> m_connectionStats =
                new HashMap<String, InvocationInfo>();

    /**
     *
     * @param name
     * @param siteId
     */
    public InitiatorStats(long siteId) {
        super(siteId, false);
        VoltDB.instance().getStatsAgent().registerStatsSource(SysProcSelector.INITIATOR, 0, this);
    }

    public static class InvocationInfo {

        /**
         * Hostname of the host this connection is with
         */
        private final String connectionHostname;

        private long lastWindowStart = System.currentTimeMillis();
        private final long POLL_WINDOW = 10000;

        /**
         * Number of time procedure has been invoked
         */
        private long allInvocationCount = 0;
        private long lastInvocationCount = 0;
        private long invocationCount = 0;

        /**
         * Shortest amount of time this procedure has executed in
         */
        private int allMinExecutionTime = Integer.MAX_VALUE;
        private int lastMinExecutionTime = Integer.MAX_VALUE;
        private int minExecutionTime = Integer.MAX_VALUE;

        /**
         * Longest amount of time this procedure has executed in
         */
        private int allMaxExecutionTime = Integer.MIN_VALUE;
        private int lastMaxExecutionTime = Integer.MIN_VALUE;
        private int maxExecutionTime = Integer.MIN_VALUE;

        //24 hours measured in milliseconds
        private final long EXECUTION_HISTOGRAM_HIGHEST_TRACKABLE = (60 * 60 * 1000);
        private final int  EXECUTION_HISTOGRAM_SIGNIFICANT_VALUE_DIGITS = 1;

        private Histogram allExecutionTimeHistogram =
                new Histogram(
                        EXECUTION_HISTOGRAM_HIGHEST_TRACKABLE,
                        EXECUTION_HISTOGRAM_SIGNIFICANT_VALUE_DIGITS);
        private Histogram lastExecutionTimeHistogram =
                new Histogram(
                        EXECUTION_HISTOGRAM_HIGHEST_TRACKABLE,
                        EXECUTION_HISTOGRAM_SIGNIFICANT_VALUE_DIGITS);
        private Histogram executionTimeHistogram =
                new Histogram(
                        EXECUTION_HISTOGRAM_HIGHEST_TRACKABLE,
                        EXECUTION_HISTOGRAM_SIGNIFICANT_VALUE_DIGITS);

        /**
         * Total amount of time spent executing procedure
         */
        private long allExecutionTime = 0;
        private long lastExecutionTime = 0;
        private long executionTime;

        private long allAbortCount = 0;
        private long lastAbortCount = 0;
        private long abortCount = 0;

        private long allFailureCount = 0;
        private long lastFailureCount = 0;
        private long failureCount = 0;


        public InvocationInfo (String hostname) {
            connectionHostname = hostname;
        }

        public void rollWindow() {
            final long now = EstTime.currentTimeMillis();
            //Second clause handles time going backwards
            if (now - lastWindowStart  > POLL_WINDOW || now < lastWindowStart) {
                lastWindowStart = now;

                //There are no invocations in this window or the last, nothing to do
                if (invocationCount == 0 &&
                        lastExecutionTimeHistogram.getHistogramData().getTotalCount() == 0) return;

                lastInvocationCount = invocationCount;
                allInvocationCount += invocationCount;
                invocationCount = 0;

                lastAbortCount = abortCount;
                allAbortCount += abortCount;
                abortCount = 0;

                lastFailureCount = failureCount;
                allFailureCount += allFailureCount;
                failureCount = 0;

                lastMinExecutionTime = minExecutionTime;
                allMinExecutionTime = Math.min(allMinExecutionTime, minExecutionTime);
                minExecutionTime = Integer.MAX_VALUE;

                lastMaxExecutionTime = maxExecutionTime;
                allMaxExecutionTime = Math.max(allMaxExecutionTime, maxExecutionTime);
                maxExecutionTime = Integer.MIN_VALUE;

                lastExecutionTime = executionTime;
                allExecutionTime += executionTime;
                executionTime = 0;

                lastExecutionTimeHistogram = executionTimeHistogram;
                executionTimeHistogram = new Histogram(
                        EXECUTION_HISTOGRAM_HIGHEST_TRACKABLE,
                        EXECUTION_HISTOGRAM_SIGNIFICANT_VALUE_DIGITS);
            }
        }

        public void processInvocation(int delta, byte status) {
            rollWindow();
            executionTime += delta;
            minExecutionTime = Math.min( delta, minExecutionTime);
            maxExecutionTime = Math.max(  delta, maxExecutionTime);
            invocationCount++;
            if (delta <= executionTimeHistogram.getHighestTrackableValue()) {
                executionTimeHistogram.recordValue(delta);
                allExecutionTimeHistogram.recordValue(delta);
            } else {
                executionTimeHistogram.recordValue(executionTimeHistogram.getHighestTrackableValue());
                allExecutionTimeHistogram.recordValue(allExecutionTimeHistogram.getHighestTrackableValue());
            }

            if (status != ClientResponse.SUCCESS) {
                if (status == ClientResponse.GRACEFUL_FAILURE || status == ClientResponse.USER_ABORT) {
                    abortCount++;
                } else {
                    failureCount++;
                }
            }
        }
    }

    /**
     * Called by the Initiator every time a transaction is completed
     * @param connectionId Id of the connection that the invocation orginated from
     * @param invocation Procedure executed
     * @param delta Time the procedure took to round trip intra cluster
     */
    public synchronized void logTransactionCompleted(
            long connectionId,
            String connectionHostname,
            StoredProcedureInvocation invocation,
            int delta,
            byte status) {
        final StringBuilder key = new StringBuilder(2048);
        key.append(invocation.getProcName()).append('$').append(connectionId);
        final String keyString = key.toString();
        InvocationInfo info = m_connectionStats.get(keyString);
        if (info == null) {
            info = new InvocationInfo(connectionHostname);
            m_connectionStats.put(keyString, info);
        }
        info.processInvocation(delta, status);
    }

    /**
     * Remove all stats of a connection.
     * @param connectionId
     */
    public synchronized void removeConnectionStats(long connectionId) {
        Set<String> keySet = m_connectionStats.keySet();
        LinkedList<String> keysToRemove = new LinkedList<String>();
        for (String key : keySet) {
            // note: use lastIndexOf below to support inner classes as procedures
            long cId = Long.parseLong(key.substring(key.lastIndexOf('$') + 1));
            if (cId == connectionId) {
                keysToRemove.add(key);
            }
        }

        for (String key : keysToRemove) {
            m_connectionStats.remove(key);
        }
        keysToRemove.clear();
    }

    @Override
    protected void populateColumnSchema(ArrayList<ColumnInfo> columns) {
        super.populateColumnSchema(columns);
        columns.add(new ColumnInfo("CONNECTION_ID", VoltType.BIGINT));
        columns.add(new ColumnInfo("CONNECTION_HOSTNAME", VoltType.STRING));
        columns.add(new ColumnInfo("PROCEDURE_NAME", VoltType.STRING));
        columns.add(new ColumnInfo("INVOCATIONS", VoltType.BIGINT));
        columns.add(new ColumnInfo("AVG_EXECUTION_TIME", VoltType.INTEGER));
        columns.add(new ColumnInfo("MIN_EXECUTION_TIME", VoltType.INTEGER));
        columns.add(new ColumnInfo("MAX_EXECUTION_TIME", VoltType.INTEGER));
        columns.add(new ColumnInfo("ABORTS", VoltType.BIGINT));
        columns.add(new ColumnInfo("FAILURES", VoltType.BIGINT));
        columns.add(new ColumnInfo("EXECUTION_TIME_99", VoltType.INTEGER));
    }

    @Override
    protected void updateStatsRow(final Object rowKey, Object rowValues[]) {
        DummyIterator iterator = (DummyIterator)rowKey;
        Map.Entry<String, InvocationInfo> entry = iterator.next;
        iterator.next = null;
        final InvocationInfo info = entry.getValue();
        final String statsKey = entry.getKey();
        final String statsKeySplit[] = statsKey.split("\\$");
        final String procName = statsKeySplit[0];
        final String connectionId = statsKeySplit[1];

        info.rollWindow();

        long invocationCount = info.allInvocationCount + info.invocationCount;
        long totalExecutionTime = info.allExecutionTime + info.executionTime;
        int minExecutionTime = Math.min(info.allMinExecutionTime, info.minExecutionTime);
        int maxExecutionTime = Math.max(info.allMaxExecutionTime, info.maxExecutionTime);
        long abortCount = info.allAbortCount + info.abortCount;
        long failureCount = info.allFailureCount + info.failureCount;
        int execution99 = 0;
        if (iterator.interval) {
            invocationCount = info.lastInvocationCount;

            totalExecutionTime = info.lastExecutionTime;

            minExecutionTime = info.lastMinExecutionTime;
            maxExecutionTime = info.lastMaxExecutionTime;

            abortCount = info.lastAbortCount;

            failureCount = info.lastFailureCount;
            if (info.lastInvocationCount > 0) {
                execution99 = (int)info.lastExecutionTimeHistogram.getHistogramData().getValueAtPercentile(.99);
            }
        } else {
            if (info.allInvocationCount > 0) {
                execution99 = (int)info.allExecutionTimeHistogram.getHistogramData().getValueAtPercentile(.99);
            }
        }

        rowValues[columnNameToIndex.get("CONNECTION_ID")] = new Long(connectionId);
        rowValues[columnNameToIndex.get("CONNECTION_HOSTNAME")] = info.connectionHostname;
        rowValues[columnNameToIndex.get("PROCEDURE_NAME")] = procName;
        rowValues[columnNameToIndex.get("INVOCATIONS")] = invocationCount;
        rowValues[columnNameToIndex.get("AVG_EXECUTION_TIME")] = (int)(totalExecutionTime / invocationCount);
        rowValues[columnNameToIndex.get("MIN_EXECUTION_TIME")] = minExecutionTime;
        rowValues[columnNameToIndex.get("MAX_EXECUTION_TIME")] = maxExecutionTime;
        rowValues[columnNameToIndex.get("ABORTS")] = abortCount;
        rowValues[columnNameToIndex.get("FAILURES")] = failureCount;
        rowValues[columnNameToIndex.get("EXECUTION_TIME_99")] = execution99;
        super.updateStatsRow(rowKey, rowValues);
    }

    /**
     * A dummy iterator that wraps an Iterator<String> and provides the Iterator<Object> necessary
     * for getStatsRowKeyIterator()
     *
     */
    private class DummyIterator implements Iterator<Object> {
        private final Iterator<Map.Entry<String, InvocationInfo>> i;
        private Map.Entry<String, InvocationInfo> next = null;
        private final boolean interval;
        private DummyIterator(Iterator<Map.Entry<String, InvocationInfo>> i, boolean interval) {
            this.i = i;
            this.interval = interval;
        }

        @Override
        public boolean hasNext() {
            if (!interval) {
                if (i.hasNext()) {
                    next = i.next();
                    return true;
                } else {
                    return false;
                }
            }
            if (!i.hasNext()) {
                return false;
            } else {
                while (next == null && i.hasNext()) {
                    Map.Entry<String, InvocationInfo> entry = i.next();
                    InvocationInfo info = entry.getValue();
                    if (info.invocationCount - info.lastInvocationCount == 0) {
                        continue;
                    } else {
                        next = entry;
                    }
                }
                if (next == null) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public Object next() {
            return this;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private class AggregatingIterator implements Iterator<Map.Entry<String, InvocationInfo>> {

        private final Queue<Iterator<Map.Entry<String, InvocationInfo>>> m_sources;
        private AggregatingIterator(Queue<Iterator<Map.Entry<String, InvocationInfo>>> sources) {
            m_sources = sources;
        }

        @Override
        public boolean hasNext() {
            Iterator<Map.Entry<String, InvocationInfo>> i = null;
            while ((i = m_sources.peek()) != null) {
                if (i.hasNext()) return true;
                m_sources.remove();
            }
            return false;
        }

        @Override
        public Map.Entry<String, InvocationInfo> next() {
            final Iterator<Map.Entry<String, InvocationInfo>> i = m_sources.peek();
            if (i == null || !i.hasNext()) {
                throw new NoSuchElementException();
            }
            return i.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

    }

    @Override
    protected Iterator<Object> getStatsRowKeyIterator(boolean interval) {
        ArrayDeque<Iterator<Map.Entry<String, InvocationInfo>>> d =
                new ArrayDeque<Iterator<Map.Entry<String, InvocationInfo>>>();
        if (VoltDB.instance().isIV2Enabled()) {
            for (ClientInterface ci : VoltDB.instance().getClientInterfaces()) {
                d.addAll(ci.getIV2InitiatorStats());
            }
        } else {
            throw new UnsupportedOperationException("PreIV2 is gone");
        }
        return new DummyIterator(
                new AggregatingIterator(d),
                interval);
    }
}
