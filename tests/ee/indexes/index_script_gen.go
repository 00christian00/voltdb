/*
 * Generate input test scripts to verify index behaviour.
 *
 * Unique / Non-unique
 * Ints-only / Not Ints-only
 * Array, Tree, Hash implementations
 * Key sizes
 */
package main

import (
    "fmt"
    "rand"
    "container/list"
    "strings"
)

// Types known to test tool that are valid index column types
var voltIdxTypes = [...]string{
    "int",
    "bint",
    "sint",
    "tint",
    "dec",
    "str4",
    "str128"}

// Maximum number of indexed columns
var maxIdxColumns = 3

func createSchema() []string {
    schema := make([]string, (rand.Int() % maxIdxColumns) + 1)
    for ii := 0; ii < len(schema); ii++ {
        schema[ii] = voltIdxTypes[rand.Int() % len(voltIdxTypes)]
    }
    return schema
}

func createTuple(schema []string) []string {
    tuple := make([]string, len(schema))
    for ii := 0; ii < len(schema); ii++ {
        switch schema[ii] {
            case "int": tuple[ii] = createIntVal()
            case "bint" : tuple[ii] = createBintVal()
            case "sint" : tuple[ii] = createSintVal()
            case "tint" : tuple[ii] = createTintVal()
            case "dec" : tuple[ii] = createDecimalVal()
            case "str4" : tuple[ii] = createStringVal(4)
            case "str128" : tuple[ii] = createStringVal(128)
            default: panic(schema[ii])
        }
    }
    return tuple
}

func sign() int {
    sign := rand.Int() % 2
    if sign == 0 {
        return 1
    }
    return -1
}

func createIntVal() string {
    val := rand.Int() * sign()
    return fmt.Sprint(val)
}

func createBintVal() string {
    val := rand.Int63()
    val = val * int64(sign())
    return fmt.Sprint(val)
}

func createSintVal() string {
    val := rand.Intn(0xFFFF) * sign()
    return fmt.Sprint(val)
}

func createTintVal() string {
    val := rand.Intn(0xFF) * sign()
    return fmt.Sprint(val)
}

func createDecimalVal() string {
    vals := make([]string, 3)
    vals[0] = createBintVal()
    vals[1] = "."
    vals[2] = fmt.Sprint(rand.Int())
    return strings.Join(vals,"")
}

func createStringVal(size int) string {
	if size == 128 {
		substrs := [...]string{"ning","izzy","ariel","nick",
			"mazur","ryan","hugg","yankeesfan","volt","runs",
			"with","scissors","blue","awesome","weak","sauce",
			"chicken","strength","vikram","bobbi","jarr","bungee",
			"banjo","arrow","trinity","coffee","pvc"}
		cnt := (rand.Int() % 10) + 1
		vals := make([]string, cnt)

		for i := 0; i < cnt; i++ {
			vals[i] = substrs[rand.Int() % len(substrs)]
		}
		return strings.Join(vals,"")
	} else if size == 4 {
		substrs := [...]string{"a","b","c","d"}
		cnt := 4
		vals := make([]string, cnt)

		for i := 0; i < cnt; i++ {
			vals[i] = substrs[rand.Int() % len(substrs)]
		}
		return strings.Join(vals,"")
	}
	panic("Invalid string size.")
}

/*
 * Commands known to the test harness:
 *
 * is : insert success
 * if : insert failure
 * ls : lookup success
 * lf : lookup failure
 * us : update success
 * uf : update failure
 */


func generateUniqueGenericTree(testrun int) {
    schema := createSchema()
    tuples := list.New()

    // print the test introduction
    fmt.Printf("begin TestUniqueGenericTree_%d UniqueGenericTree ", testrun)
    printSliceAsList(schema)

    // print the test commands
    for cmd := 0; cmd < 10; cmd++ {
        tuple := createTuple(schema)
        tuples.PushBack(tuple)
        fmt.Printf("is ")
        printSliceAsList(tuple)
    }

    // print the verification commands
    for e := range tuples.Iter() {
        fmt.Printf("ls ")
        printSliceAsList(e.([]string))
    }

    fmt.Println("exec")
}

func printSliceAsList(slice []string) {
    for i := 0; i < len(slice); i++ {
        fmt.Printf(slice[i])
        if (i == len(slice) - 1) {
            fmt.Printf("\n")
        } else {
            fmt.Printf(",")
        }
    }
}

func main() {
    fmt.Printf("# File generated by index_script_gen.go\n")
	var i int = 0
    for {
        generateUniqueGenericTree(i)
		i++
    }
    fmt.Println("done")
}
